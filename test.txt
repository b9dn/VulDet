Role: Act as an Expert Security Code Auditor specializing in C/C++ memory safety and pointer arithmetic.

Task: Conduct a deep-dive security analysis of the provided C code to identify exploitable vulnerabilities (e.g., CWE-119, CWE-190, CWE-476, CWE-822).

Instructions:
1. Data Flow Trace: For the specified function, create a step-by-step trace of critical variables. Specifically, note how 'length' or 'size' variables change and how they are used in memory allocations or array indexing.
2. Pointer & Boundary Analysis: 
   - Identify every array access or pointer dereference. 
   - State the maximum possible value of the index vs. the allocated size.
   - Check for "Off-by-one" errors in loop termination conditions (e.g., <= vs <).
3. Integer Safety: Check all arithmetic involving `size_t`, `int`, or `uint16_t`. Explicitly look for:
   - Underflow when subtracting from a length (e.g., len - 8).
   - Overflow when calculating allocation sizes (e.g., count * size).
   - Sign-extension issues when casting signed to unsigned.
4. Edge Case Validation: Evaluate behavior for:
   - Empty inputs (len = 0, NULL pointers).
   - Minimum/Maximum integer values.
   - Malformed headers or control characters.

Output Format:
- Technical Breakdown: [Detailed analysis of data flow and arithmetic]
- Vulnerability Type: [e.g., Heap Buffer Overflow, Integer Underflow]
- Trigger Scenario: [What specific input causes the crash/exploit?]
- [RESULT]: VULNERABLE or SAFE

in one last line summarize you answers with this format:

Sample 1: Safe | Vulnerable ;Sample 2: Safe | Vulnerable

Samples Code:
Sample 1 (functions to check for vulnerability: file_extension):
```
const char *			/* O - File extension */ /* <=== file_extension */ 
file_extension(const char *s)	/* I - Filename or URL */
{
  const char	*extension;	/* Pointer to directory separator */
  char		*bufptr;	/* Pointer into buffer */
  static char	buf[1024];	/* Buffer for files with targets */


  if (s == NULL)
    return (NULL);
  else if (!strncmp(s, "data:image/bmp;", 15))
    return ("bmp");
  else if (!strncmp(s, "data:image/gif;", 15))
    return ("gif");
  else if (!strncmp(s, "data:image/jpeg;", 16))
    return ("jpg");
  else if (!strncmp(s, "data:image/png;", 15))
    return ("png");
  else if ((extension = strrchr(s, '/')) != NULL)
    extension ++;
  else if ((extension = strrchr(s, '\\')) != NULL)
    extension ++;
  else
    extension = s;

  if ((extension = strrchr(extension, '.')) == NULL)
    return ("");
  else
    extension ++;

  if (strchr(extension, '#') == NULL)
    return (extension);

  strlcpy(buf, extension, sizeof(buf));

  if ((bufptr = strchr(buf, '#')) != NULL)
    *bufptr = '\0';

  return (buf);
}

```
Sample 2 (functions to check for vulnerability: session_identity_decode):
```
static apr_status_t session_identity_decode(request_rec * r, session_rec * z) /* <=== session_identity_decode */ 
{

    char *last = NULL;
    char *encoded, *pair;
    const char *sep = "&";

    /* sanity check - anything to decode? */
    if (!z->encoded) {
        return OK;
    }

    /* decode what we have */
    encoded = apr_pstrdup(r->pool, z->encoded);
    pair = apr_strtok(encoded, sep, &last);
    while (pair && pair[0]) {
        char *plast = NULL;
        const char *psep = "=";
        char *key = apr_strtok(pair, psep, &plast);
        if (key && *key) {
            char *val = apr_strtok(NULL, sep, &plast);
            if (!val || !*val) {
                apr_table_unset(z->entries, key);
            }
            else if (!ap_unescape_urlencoded(key) && !ap_unescape_urlencoded(val)) {
                if (!strcmp(SESSION_EXPIRY, key)) {
                    z->expiry = (apr_time_t) apr_atoi64(val);
                }
                else {
                    apr_table_set(z->entries, key, val);
                }
            }
        }
        pair = apr_strtok(NULL, sep, &last);
    }
    z->encoded = NULL;
    return OK;

}

```
Sample 3 (functions to check for vulnerability: mem_resize):
```
static int mem_resize(jas_stream_memobj_t *m, int bufsize) /* <=== mem_resize */ 
{
	unsigned char *buf;

	//assert(m->buf_);
	assert(bufsize >= 0);
	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
	  bufsize) {
		return -1;
	}
	m->buf_ = buf;
	m->bufsize_ = bufsize;
	return 0;
}

```
Sample 4 (functions to check for vulnerability: calcstepsizes):
```
static int calcstepsizes(uint_fast16_t refstepsize, int numrlvls, /* <=== calcstepsizes */ 
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t expn;
	uint_fast16_t mant;
	expn = JPC_QCX_GETEXPN(refstepsize);
	mant = JPC_QCX_GETMANT(refstepsize);
	numbands = 3 * numrlvls - 2;
	for (bandno = 0; bandno < numbands; ++bandno) {
//jas_eprintf("DEBUG %d %d %d %d %d\n", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));
		uint_fast16_t e = expn + (bandno + 2) / 3;
		if (e >= 0x20)
			return -1;
		stepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(e);
	}
	return 0;
}

```
Sample 5 (functions to check for vulnerability: check_1_6_dummy):
```
static void /* <=== check_1_6_dummy */ 
check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
    char *password = *passptr;

    /* Old-style randkey operations disallowed tickets to start. */
    if (password == NULL || !(mask & KADM5_ATTRIBUTES) ||
        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
        return;

    /* The 1.6 dummy password was the octets 1..255. */
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;

    /* This will make the caller use a random password instead. */
    *passptr = NULL;
}

```