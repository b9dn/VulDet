import dotenv from "dotenv";
import sqlite from "sqlite3";
import { GoogleGenAI } from "@google/genai";

dotenv.config();
const ai = new GoogleGenAI({ apiKey: process.env.GEMINI });
const db = new sqlite.Database("./formatted_data/data_test.sqlite");

// const name = "gemini-2.5-flash";
// const name = "tngtech/deepseek-r1t2-chimera:free";
const name = "openai/gpt-oss-120b:free";
const isGemini = false;
const graphType = "cpg14"; // cfg, pdg, cpg14, cdg, ddg, json_graph_cpg_1

const prompt = `
You are an expert in program analysis and Code Property Graphs (CPG).

Your task is to transform a Code Property Graph exported by Joern in DOT format into a normalized edge-list representation with predefined edge types.

========================
INPUT
========================

You will receive a graph in DOT format generated by Joern.

The DOT graph contains:

* Node definitions with unique numeric IDs and attribute lists (e.g., label, code, name, type, etc.).
* Directed edges between node IDs with optional labels (e.g., AST, CFG, CDG, REACHING_DEF, DOMINATE, POST_DOMINATE, REF, etc.).

Do not assume that any specific node attributes are always present.
Use only information explicitly available in the DOT input.

========================
GOAL
========================

Transform the graph into two tables:

1. NODE TABLE
   Format:
   NodeID | NodeType | Code

Where:

* NodeID = original numeric ID from DOT.
* NodeType = value of the node’s type-related attribute if present (e.g., type, label, or similar). If multiple candidates exist, prefer a structural type over a textual label.
* Code = value of a code-related attribute if present (e.g., code, name). If not present, leave empty.

2. EDGE TABLE
   Format:
   SourceNodeID | TargetNodeID | EdgeType

========================
ALLOWED EDGE TYPES
========================

Use ONLY the following edge types:

IS_CLASS_OF
IS_FUNCTION_OF_AST
IS_FUNCTION_OF_CFG
IS_AST_PARENT
USE
DEF
DOM
POST_DOM
CONTROLS
DECLARES
FLOWS_TO
REACHES

If an edge cannot be mapped to one of these types using explicit information from the DOT input, ignore it.

========================
EDGE TYPE MAPPING
========================

Map edges strictly based on their DOT label:

AST → IS_AST_PARENT
CFG → FLOWS_TO
CDG → CONTROLS
DOMINATE → DOM
POST_DOMINATE → POST_DOM
REACHING_DEF → REACHES
REF → USE

If the DOT graph explicitly indicates:

* a declaration relation → DECLARES
* a definition relation → DEF
* class inheritance → IS_CLASS_OF
* function-to-AST root relation → IS_FUNCTION_OF_AST
* function-to-CFG root relation → IS_FUNCTION_OF_CFG

Otherwise, do not infer such relations.

========================
STRICT RULES
========================

* Do NOT invent nodes.
* Do NOT infer missing edges.
* Use ONLY nodes and edges explicitly present in the DOT input.
* Preserve original node IDs.
* Output must contain ONLY:

  * NODES
  * EDGES
* No explanations.
* No commentary.
* No markdown formatting.
* Deterministic output.

========================
OUTPUT FORMAT
========================

NODES
NodeID | NodeType | Code
...

EDGES
SourceNodeID | TargetNodeID | EdgeType
...

========================
Now transform the following DOT graph:
`

const sendMessageOR = async (data, model, key = process.env.OPENROUTER) => {

  const messages = [
    {
      role: "user",
      content: prompt + data[graphType]
    },
  ];

  const response = await fetch(
    "https://openrouter.ai/api/v1/chat/completions",
    {
      method: "POST",
      headers: {
        Authorization: `Bearer ${key}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: model,
        messages: messages,
        reasoning: { enabled: true },
      }),
    }
  );

  if (!response.ok) {
    const body = await response.text();
    console.error("HTTP ERROR:", response.status, body);
    throw new Error(`Request failed with status ${response.status}`);
  }

  const result = await response.json();

  const generatedGraph =
    result.choices[0].message.content.trim();

  console.log(`Generated graph = ${generatedGraph}`);

  const stmt = db.prepare(`
    UPDATE data
    SET llm_textgraph = ?
    WHERE id = ?
  `);

  stmt.run(generatedGraph, data.id);

  console.log(`Zapisano graf dla ID ${data.id}`);
};

const sendMessageGemini = async (data, model) => {
  const response = await ai.models.generateContent({
    model: model,
    contents: prompt + data[graphType],
  });

  const generatedGraph = response.text.trim();

  db.prepare(`
    UPDATE data
    SET llm_textgraph = ?
    WHERE id = ?
  `).run(generatedGraph, data.id);

  console.log(`Zapisano graf (Gemini) dla ID ${data.id}`);
};


const sleep = (ms) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};

const whereClause = `WHERE llm_textgraph IS NULL OR llm_textgraph = ''`;

// db.exec(`ALTER TABLE data ADD COLUMN llm_textgraph TEXT DEFAULT NULL`);

db.all(
  `SELECT * FROM data ${whereClause} LIMIT 10`,
  async (err, rows) => {
    if (err) return console.error(err.message);

    try {
      for (const data of rows) {
        const promise = isGemini
          ? sendMessageGemini(data, name)
          : sendMessageOR(data, name);

        await promise;

        console.log("Success");
        await sleep(1000);
      }
    } catch (err) {
      console.error("PROCESS STOPPED:", err.message);
    }
  }
);
